# Munchies i18n Design

## Overview

Full internationalization of the Munchies e-commerce platform across Sanity CMS, Astro frontend, and Medusa backend. Two languages: Romanian (primary) and English.

## Decisions

- **Languages:** `ro` (Romanian, primary), `en` (English)
- **URL structure:** `/{language}/...` — always prefixed (`/ro/...`, `/en/...`)
- **Translated URLs:** Both static segments and dynamic slugs are translated per language
- **Region/country:** Cookie-based (IP auto-detection + picker), never in URL
- **Sanity i18n approach:** `@sanity/internationalized-array` plugin — translations stored as arrays on each field
- **Product content source of truth:** Sanity (Medusa holds commerce data only)
- **Medusa products:** Romanian language, sync writes to `ro` entry in Sanity i18n arrays
- **Fallback:** Always fall back to `ro` if a translation is missing

## Section 1: Language & Route Configuration

### URL Structure

All URLs prefixed with language: `/ro/...` and `/en/...`.

Root `/` detects browser `Accept-Language` and 302 redirects to `/ro/` or `/en/`.

### Static Route Segment Map

Defined in `apps/web/src/i18n/routes.ts`:

| Canonical (code) | Romanian (`ro`) | English (`en`) |
|---|---|---|
| products | produse | products |
| checkout | finalizare | checkout |
| order | comanda | order |
| confirmed | confirmata | confirmed |
| faqs | intrebari | faqs |

### Middleware Flow

1. If path is `/` — detect browser language — 302 redirect to `/ro/` or `/en/`
2. Extract first segment as language (`ro`/`en`), 302 to `/ro/...` if unrecognized
3. Read country code from cookie (fallback: IP via Cloudflare `cf-ipcountry` header, then `ro`)
4. Translate static route segments to canonical form for internal routing
5. Set `Astro.locals.language`, `Astro.locals.countryCode`

### Config Changes

`apps/web/src/config.ts`: Add `supportedLanguages: ["ro", "en"]`, `defaultLanguage: "ro"`. Keep `supportedCountryCodes` as-is for Medusa regions.

## Section 2: Sanity Schema Changes

### Plugin

Install `@sanity/internationalized-array`. Configure with languages `ro` and `en`.

### Field Migration

Every user-facing text field becomes an internationalized array. Structural/technical fields stay as-is.

**Documents:**

| Type | Fields becoming i18n | Fields staying as-is |
|---|---|---|
| product | title, description, specs, addons.title, slug | _id, _type, references, sections, images |
| modular.page | title, slug (pathname) | _type, sections (sections have own i18n fields) |
| text.page | title, description, body, slug | _type |
| category | internalTitle, slug | _type |
| collection | internalTitle, slug | _type |
| testimonial | text content fields | _type, image |

**Singletons:**

| Type | Fields becoming i18n | Fields staying as-is |
|---|---|---|
| header | announcementText, navigation labels | showAnnouncement, structure, references |
| footer | copy, signup_success, signup_error, placeholder, button, footnote, link labels | image, socialLinks URLs, structure |
| home | title | sections (handled inside each section) |
| not.found | text, cta.label | cta.link |
| cookie.banner | title, description, rejectButton, acceptButton | -- |
| dictionary | noResultsText, noResultsDescription | -- |
| faq.index | title, description, searchPlaceholder, searchNoResults | category references |

**Section objects** (hero, media-text, etc.): Each section's text fields (title, subtitle, CTA labels) become internationalized arrays. Non-text fields (images, videos, layout options) stay as-is.

**Object types:**
- `cta` — `label` becomes i18n, `link` stays as-is
- `seo` — `title`, `description` become i18n
- `ptBody` / `lightPtBody` — portable text content becomes i18n

### Slug/Pathname Handling

Replace the `pathname` field from `@tinloof/sanity-extends` with an internationalized slug object. Each document stores slugs per language.

### GROQ Query Pattern

Current: `*[pathname.current == $pathname]`
New: `*[slug[$language].current == $slug]`

Content field resolution: `"title": title[$language]` — resolved in GROQ projections so components receive flat strings.

### Medusa Product Sync

Sync writes into the `ro` entry of internationalized arrays:
```
title: [{_key: "ro", value: "Biscuiti cu ciocolata"}]
```

## Section 3: Astro Frontend i18n

### New `apps/web/src/i18n/` Module

- `routes.ts` — Static segment translation map
- `languages.ts` — Language config, default language, supported languages
- `translations.ts` — Static UI strings not from Sanity (e.g., "Add to cart", "Quantity")
- `helpers.ts` — Utility functions:
  - `getLocalizedPath(language, canonicalPath)` — builds translated URLs
  - `getCanonicalPath(language, localizedPath)` — reverse translation for Sanity lookups
  - `getAlternateUrl(currentPath, targetLanguage)` — for language switcher and hreflang
  - `t(key, language)` — static string lookup

### Middleware

Replace `countryCodeMiddleware` with `languageMiddleware` + `regionMiddleware`:

**languageMiddleware:** Root redirect, language extraction, static segment translation, sets `Astro.locals.language`.

**regionMiddleware:** Cookie-based region with `cf-ipcountry` fallback, sets `Astro.locals.countryCode`.

### Page Routing

`[...path]` catch-all stays. Resolution flow:

```
URL: /ro/produse/biscuiti-cu-ciocolata
  -> language: "ro"
  -> canonical segments: ["products", "biscuiti-cu-ciocolata"]
  -> route type: "product" (first segment is "products")
  -> GROQ: find product where slug.ro == "biscuiti-cu-ciocolata"
  -> render with language="ro", i18n fields resolved via GROQ
```

### Component Changes

Resolve i18n at GROQ query time. Components receive flat strings (like today). No i18n awareness needed in templates.

`LocalizedLink` updated to use `getLocalizedPath()` with language.

### SEO

- `<html lang="ro">` or `<html lang="en">`
- `<link rel="alternate" hreflang="ro">` and `hreflang="en"` on every page
- `hreflang="x-default"` points to `/ro/...`
- Sanity SEO fields resolved per language

### Language Switcher

RO/EN toggle in header. Each page fetches both language slugs so the switcher knows the alternate URL.

### Region Picker

Separate UI element for selecting country/region. Updates cookie, triggers re-fetch of Medusa pricing data.

## Section 4: Medusa & Region Handling

### No Medusa i18n Changes

Medusa stays as commerce engine. Products in Romanian. Storefront pulls display content from Sanity, commerce data from Medusa.

### Region Detection

1. `cf-ipcountry` header gives country on first visit
2. Set `region` cookie if country is in `supportedCountryCodes`, else `ro`
3. User can override via region picker

### Cart & Checkout

Cart tied to Medusa region (cookie-based). Switching language re-renders with translated labels. Cart persists across language switches.

## Section 5: Migration & Rollout

### Phases

**Phase 1 — Sanity schema + plugin:** Install plugin, update schemas, deploy.

**Phase 2 — Data migration:** Script converts `title: "Foo"` to `title: [{_key: "ro", value: "Foo"}]` for all documents. English values start empty. Fallback to `ro` in GROQ.

**Phase 3 — Astro frontend:** Add i18n module, replace middleware, update GROQ queries, update links, add language switcher, add region picker, update SEO tags.

**Phase 4 — Product sync:** Update sync script to write i18n arrays, re-sync all products.

### Fallback

GROQ uses `coalesce(title[$language], title[_key == "ro"][0].value)` — site works immediately after migration with all content in Romanian. English added progressively.

### Breaking Changes

- All GROQ queries parameterized by `$language`
- Pathname routing changes to slug-per-language
- `getLocalizedHref` rewritten
- Middleware completely reworked
- Big-bang deploy (routing fundamentally changes)

### No Redirects (MVP)

Old URL patterns are not redirected. This is an MVP — clean cutover.
